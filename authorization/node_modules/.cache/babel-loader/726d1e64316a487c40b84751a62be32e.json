{"ast":null,"code":"'use strict';\n\nvar Query = require('../connection/commands').Query;\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar MongoError = require('../error').MongoError;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar getReadPreference = require('./shared').getReadPreference;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long;\n\nvar ReadPreference = require('../topologies/read_preference');\n\nvar TxnState = require('../transactions').TxnState;\n\nvar WireProtocol = function WireProtocol() {};\n\nfunction isTransactionCommand(command) {\n  return !!(command.commitTransaction || command.abortTransaction);\n}\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param {Object} command the command to decorate\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} [options] Optional settings passed to calling operation\n * @param {Function} [callback] Optional callback passed from calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\n\n\nfunction decorateWithSessionsData(command, session, options) {\n  if (!session) {\n    return;\n  } // first apply non-transaction-specific sessions data\n\n\n  var serverSession = session.serverSession;\n  var inTransaction = session.inTransaction() || isTransactionCommand(command);\n  var isRetryableWrite = options.willRetryWrite;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  } // now attempt to apply transaction-specific sessions data\n\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    } // for causal consistency\n\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(\"Read preference in a transaction must be primary, not: \".concat(options.readPreference.mode));\n  } // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n} //\n// Execute a write operation\n\n\nfunction executeWrite(pool, bson, type, opsField, ns, ops, options, callback) {\n  if (ops.length === 0) throw new MongoError('insert must contain at least one document');\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n    options = options || {};\n  } // Split the ns up to get db and collection\n\n\n  var p = ns.split('.');\n  var d = p.shift(); // Options\n\n  var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  var writeConcern = options.writeConcern; // return skeleton\n\n  var writeCommand = {};\n  writeCommand[type] = p.join('.');\n  writeCommand[opsField] = ops;\n  writeCommand.ordered = ordered; // Did we specify a write concern\n\n  if (writeConcern && Object.keys(writeConcern).length > 0) {\n    writeCommand.writeConcern = writeConcern;\n  } // If we have collation passed in\n\n\n  if (options.collation) {\n    for (var i = 0; i < writeCommand[opsField].length; i++) {\n      if (!writeCommand[opsField][i].collation) {\n        writeCommand[opsField][i].collation = options.collation;\n      }\n    }\n  } // Do we have bypassDocumentValidation set, then enable it on the write command\n\n\n  if (options.bypassDocumentValidation === true) {\n    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;\n  } // optionally decorate command with transactions data\n\n\n  var err = decorateWithSessionsData(writeCommand, options.session, options, callback);\n\n  if (err) {\n    return callback(err, null);\n  } // Options object\n\n\n  var opts = {\n    command: true\n  };\n  if (typeof options.session !== 'undefined') opts.session = options.session;\n  var queryOptions = {\n    checkKeys: false,\n    numberToSkip: 0,\n    numberToReturn: 1\n  };\n  if (type === 'insert') queryOptions.checkKeys = true;\n  if (typeof options.checkKeys === 'boolean') queryOptions.checkKeys = options.checkKeys; // Ensure we support serialization of functions\n\n  if (options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions; // Do not serialize the undefined fields\n\n  if (options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;\n\n  try {\n    // Create write command\n    var cmd = new Query(bson, \"\".concat(d, \".$cmd\"), writeCommand, queryOptions); // Execute command\n\n    pool.write(cmd, opts, callback);\n  } catch (err) {\n    callback(err);\n  }\n} //\n// Needs to support legacy mass insert as well as ordered/unordered legacy\n// emulation\n//\n\n\nWireProtocol.prototype.insert = function (pool, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.update = function (pool, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.remove = function (pool, ns, bson, ops, options, callback) {\n  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);\n};\n\nWireProtocol.prototype.killCursor = function (bson, ns, cursorState, pool, callback) {\n  // Build command namespace\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = \"\".concat(parts.shift(), \".$cmd\");\n  var cursorId = cursorState.cursorId; // Create killCursor command\n\n  var killcursorCmd = {\n    killCursors: parts.join('.'),\n    cursors: [cursorId]\n  }; // Build Query object\n\n  var query = new Query(bson, commandns, killcursorCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    returnFieldSelector: null\n  }); // Kill cursor callback\n\n  function killCursorCallback(err, result) {\n    if (err) {\n      if (typeof callback !== 'function') return;\n      return callback(err);\n    } // Result\n\n\n    var r = result.message; // If we have a timed out query or a cursor that was killed\n\n    if ((r.responseFlags & 1 << 0) !== 0) {\n      if (typeof callback !== 'function') return;\n      return callback(new MongoNetworkError('cursor killed or timed out'), null);\n    }\n\n    if (!Array.isArray(r.documents) || r.documents.length === 0) {\n      if (typeof callback !== 'function') return;\n      return callback(new MongoError(\"invalid killCursors result returned for cursor id \".concat(cursorId)));\n    } // Return the result\n\n\n    if (typeof callback === 'function') {\n      callback(null, r.documents[0]);\n    }\n  }\n\n  var options = {\n    command: true\n  };\n\n  if (typeof cursorState.session === 'object') {\n    options.session = cursorState.session;\n  } // Execute the kill cursor command\n\n\n  if (pool && pool.isConnected()) {\n    try {\n      pool.write(query, options, killCursorCallback);\n    } catch (err) {\n      killCursorCallback(err, null);\n    }\n\n    return;\n  } // Callback\n\n\n  if (typeof callback === 'function') callback(null, null);\n};\n\nWireProtocol.prototype.getMore = function (bson, ns, cursorState, batchSize, raw, connection, options, callback) {\n  options = options || {}; // Build command namespace\n\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = \"\".concat(parts.shift(), \".$cmd\"); // Create getMore command\n\n  var getMoreCmd = {\n    getMore: cursorState.cursorId,\n    collection: parts.join('.'),\n    batchSize: Math.abs(batchSize)\n  }; // optionally decorate command with transactions data\n\n  var err = decorateWithSessionsData(getMoreCmd, options.session, options, callback);\n\n  if (err) {\n    return callback(err, null);\n  }\n\n  if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === 'number') {\n    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;\n  } // Build Query object\n\n\n  var query = new Query(bson, commandns, getMoreCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    returnFieldSelector: null\n  }); // Query callback\n\n  function queryCallback(err, result) {\n    if (err) return callback(err); // Get the raw message\n\n    var r = result.message; // If we have a timed out query or a cursor that was killed\n\n    if ((r.responseFlags & 1 << 0) !== 0) {\n      return callback(new MongoNetworkError('cursor killed or timed out'), null);\n    } // Raw, return all the extracted documents\n\n\n    if (raw) {\n      cursorState.documents = r.documents;\n      cursorState.cursorId = r.cursorId;\n      return callback(null, r.documents);\n    } // We have an error detected\n\n\n    if (r.documents[0].ok === 0) {\n      return callback(new MongoError(r.documents[0]));\n    } // Ensure we have a Long valid cursor id\n\n\n    var cursorId = typeof r.documents[0].cursor.id === 'number' ? Long.fromNumber(r.documents[0].cursor.id) : r.documents[0].cursor.id; // Set all the values\n\n    cursorState.documents = r.documents[0].cursor.nextBatch;\n    cursorState.cursorId = cursorId; // Return the result\n\n    callback(null, r.documents[0], r.connection);\n  } // Query options\n\n\n  var queryOptions = {\n    command: true\n  }; // If we have a raw query decorate the function\n\n  if (raw) {\n    queryOptions.raw = raw;\n  } // Add the result field needed\n\n\n  queryOptions.documentsReturnedIn = 'nextBatch'; // Check if we need to promote longs\n\n  if (typeof cursorState.promoteLongs === 'boolean') {\n    queryOptions.promoteLongs = cursorState.promoteLongs;\n  }\n\n  if (typeof cursorState.promoteValues === 'boolean') {\n    queryOptions.promoteValues = cursorState.promoteValues;\n  }\n\n  if (typeof cursorState.promoteBuffers === 'boolean') {\n    queryOptions.promoteBuffers = cursorState.promoteBuffers;\n  }\n\n  if (typeof cursorState.session === 'object') {\n    queryOptions.session = cursorState.session;\n  } // Write out the getMore command\n\n\n  connection.write(query, queryOptions, queryCallback);\n};\n\nWireProtocol.prototype.command = function (bson, ns, cmd, cursorState, topology, options) {\n  options = options || {}; // Check if this is a wire protocol command or not\n\n  var wireProtocolCommand = typeof options.wireProtocolCommand === 'boolean' ? options.wireProtocolCommand : true; // Establish type of command\n\n  var query;\n\n  if (cmd.find && wireProtocolCommand) {\n    // Create the find command\n    query = executeFindCommand(bson, ns, cmd, cursorState, topology, options); // Mark the cmd as virtual\n\n    cmd.virtual = false; // Signal the documents are in the firstBatch value\n\n    query.documentsReturnedIn = 'firstBatch';\n  } else if (cursorState.cursorId != null) {\n    return;\n  } else if (cmd) {\n    query = setupCommand(bson, ns, cmd, cursorState, topology, options);\n  } else {\n    return new MongoError(\"command \".concat(JSON.stringify(cmd), \" does not return a cursor\"));\n  }\n\n  if (query instanceof MongoError) {\n    return query;\n  } // optionally decorate query with transaction data\n\n\n  var err = decorateWithSessionsData(query.query, options.session, options);\n\n  if (err) {\n    return err;\n  }\n\n  return query;\n}; // // Command\n// {\n//     find: ns\n//   , query: <object>\n//   , limit: <n>\n//   , fields: <object>\n//   , skip: <n>\n//   , hint: <string>\n//   , explain: <boolean>\n//   , snapshot: <boolean>\n//   , batchSize: <n>\n//   , returnKey: <boolean>\n//   , maxScan: <n>\n//   , min: <n>\n//   , max: <n>\n//   , showDiskLoc: <boolean>\n//   , comment: <string>\n//   , maxTimeMS: <n>\n//   , raw: <boolean>\n//   , readPreference: <ReadPreference>\n//   , tailable: <boolean>\n//   , oplogReplay: <boolean>\n//   , noCursorTimeout: <boolean>\n//   , awaitdata: <boolean>\n//   , exhaust: <boolean>\n//   , partial: <boolean>\n// }\n// FIND/GETMORE SPEC\n// {\n//     “find”: <string>,\n//     “filter”: { ... },\n//     “sort”: { ... },\n//     “projection”: { ... },\n//     “hint”: { ... },\n//     “skip”: <int>,\n//     “limit”: <int>,\n//     “batchSize”: <int>,\n//     “singleBatch”: <bool>,\n//     “comment”: <string>,\n//     “maxScan”: <int>,\n//     “maxTimeMS”: <int>,\n//     “max”: { ... },\n//     “min”: { ... },\n//     “returnKey”: <bool>,\n//     “showRecordId”: <bool>,\n//     “snapshot”: <bool>,\n//     “tailable”: <bool>,\n//     “oplogReplay”: <bool>,\n//     “noCursorTimeout”: <bool>,\n//     “awaitData”: <bool>,\n//     “partial”: <bool>,\n//     “$readPreference”: { ... }\n// }\n//\n// Execute a find command\n\n\nfunction executeFindCommand(bson, ns, cmd, cursorState, topology, options) {\n  // Ensure we have at least some options\n  options = options || {}; // Get the readPreference\n\n  var readPreference = getReadPreference(cmd, options); // Set the optional batchSize\n\n  cursorState.batchSize = cmd.batchSize || cursorState.batchSize; // Build command namespace\n\n  var parts = ns.split(/\\./); // Command namespace\n\n  var commandns = \"\".concat(parts.shift(), \".$cmd\"); // Build actual find command\n\n  var findCmd = {\n    find: parts.join('.')\n  }; // I we provided a filter\n\n  if (cmd.query) {\n    // Check if the user is passing in the $query parameter\n    if (cmd.query['$query']) {\n      findCmd.filter = cmd.query['$query'];\n    } else {\n      findCmd.filter = cmd.query;\n    }\n  } // Sort value\n\n\n  var sortValue = cmd.sort; // Handle issue of sort being an Array\n\n  if (Array.isArray(sortValue)) {\n    var sortObject = {};\n\n    if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {\n      var sortDirection = sortValue[1]; // Translate the sort order text\n\n      if (sortDirection === 'asc') {\n        sortDirection = 1;\n      } else if (sortDirection === 'desc') {\n        sortDirection = -1;\n      } // Set the sort order\n\n\n      sortObject[sortValue[0]] = sortDirection;\n    } else {\n      for (var i = 0; i < sortValue.length; i++) {\n        var _sortDirection = sortValue[i][1]; // Translate the sort order text\n\n        if (_sortDirection === 'asc') {\n          _sortDirection = 1;\n        } else if (_sortDirection === 'desc') {\n          _sortDirection = -1;\n        } // Set the sort order\n\n\n        sortObject[sortValue[i][0]] = _sortDirection;\n      }\n    }\n\n    sortValue = sortObject;\n  } // Add sort to command\n\n\n  if (cmd.sort) findCmd.sort = sortValue; // Add a projection to the command\n\n  if (cmd.fields) findCmd.projection = cmd.fields; // Add a hint to the command\n\n  if (cmd.hint) findCmd.hint = cmd.hint; // Add a skip\n\n  if (cmd.skip) findCmd.skip = cmd.skip; // Add a limit\n\n  if (cmd.limit) findCmd.limit = cmd.limit; // Check if we wish to have a singleBatch\n\n  if (cmd.limit < 0) {\n    findCmd.limit = Math.abs(cmd.limit);\n    findCmd.singleBatch = true;\n  } // Add a batchSize\n\n\n  if (typeof cmd.batchSize === 'number') {\n    if (cmd.batchSize < 0) {\n      if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {\n        findCmd.limit = Math.abs(cmd.batchSize);\n      }\n\n      findCmd.singleBatch = true;\n    }\n\n    findCmd.batchSize = Math.abs(cmd.batchSize);\n  } // If we have comment set\n\n\n  if (cmd.comment) findCmd.comment = cmd.comment; // If we have maxScan\n\n  if (cmd.maxScan) findCmd.maxScan = cmd.maxScan; // If we have maxTimeMS set\n\n  if (cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS; // If we have min\n\n  if (cmd.min) findCmd.min = cmd.min; // If we have max\n\n  if (cmd.max) findCmd.max = cmd.max; // If we have returnKey set\n\n  findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false; // If we have showDiskLoc set\n\n  findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false; // If we have snapshot set\n\n  if (cmd.snapshot) findCmd.snapshot = cmd.snapshot; // If we have tailable set\n\n  if (cmd.tailable) findCmd.tailable = cmd.tailable; // If we have oplogReplay set\n\n  if (cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay; // If we have noCursorTimeout set\n\n  if (cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout; // If we have awaitData set\n\n  if (cmd.awaitData) findCmd.awaitData = cmd.awaitData;\n  if (cmd.awaitdata) findCmd.awaitData = cmd.awaitdata; // If we have partial set\n\n  if (cmd.partial) findCmd.partial = cmd.partial; // If we have collation passed in\n\n  if (cmd.collation) findCmd.collation = cmd.collation; // If we have explain, we need to rewrite the find command\n  // to wrap it in the explain command\n\n  if (cmd.explain) {\n    findCmd = {\n      explain: findCmd\n    };\n  } // Did we provide a readConcern\n\n\n  if (cmd.readConcern) findCmd.readConcern = cmd.readConcern; // Set up the serialize and ignoreUndefined fields\n\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false; // We have a Mongos topology, check if we need to add a readPreference\n\n  if (topology.type === 'mongos' && readPreference && readPreference.preference !== 'primary') {\n    findCmd = {\n      $query: findCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  } // optionally decorate query with transaction data\n\n\n  var err = decorateWithSessionsData(findCmd, options.session, options);\n\n  if (err) {\n    return err;\n  } // Build Query object\n\n\n  var query = new Query(bson, commandns, findCmd, {\n    numberToSkip: 0,\n    numberToReturn: 1,\n    checkKeys: false,\n    returnFieldSelector: null,\n    serializeFunctions: serializeFunctions,\n    ignoreUndefined: ignoreUndefined\n  }); // Set query flags\n\n  query.slaveOk = readPreference.slaveOk(); // Return the query\n\n  return query;\n} //\n// Set up a command cursor\n\n\nfunction setupCommand(bson, ns, cmd, cursorState, topology, options) {\n  // Set empty options object\n  options = options || {}; // Get the readPreference\n\n  var readPreference = getReadPreference(cmd, options); // Final query\n\n  var finalCmd = {};\n\n  for (var name in cmd) {\n    finalCmd[name] = cmd[name];\n  } // Build command namespace\n\n\n  var parts = ns.split(/\\./); // Serialize functions\n\n  var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; // Set up the serialize and ignoreUndefined fields\n\n  var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false; // We have a Mongos topology, check if we need to add a readPreference\n\n  if (topology.type === 'mongos' && readPreference && readPreference.preference !== 'primary') {\n    finalCmd = {\n      $query: finalCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  } // optionally decorate query with transaction data\n\n\n  var err = decorateWithSessionsData(finalCmd, options.session, options);\n\n  if (err) {\n    return err;\n  } // Build Query object\n\n\n  var query = new Query(bson, \"\".concat(parts.shift(), \".$cmd\"), finalCmd, {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false,\n    serializeFunctions: serializeFunctions,\n    ignoreUndefined: ignoreUndefined\n  }); // Set query flags\n\n  query.slaveOk = readPreference.slaveOk(); // Return the query\n\n  return query;\n}\n\nmodule.exports = WireProtocol;","map":null,"metadata":{},"sourceType":"script"}