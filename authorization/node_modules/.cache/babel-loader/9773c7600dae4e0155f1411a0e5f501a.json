{"ast":null,"code":"'use strict';\n\nvar executeOperation = require('./utils').executeOperation;\n\nvar applyWriteConcern = require('./utils').applyWriteConcern;\n\nvar addUser = require('./operations/db_ops').addUser;\n\nvar executeDbAdminCommand = require('./operations/db_ops').executeDbAdminCommand;\n\nvar removeUser = require('./operations/db_ops').removeUser;\n\nvar replSetGetStatus = require('./operations/admin_ops').replSetGetStatus;\n\nvar serverStatus = require('./operations/admin_ops').serverStatus;\n\nvar validateCollection = require('./operations/admin_ops').validateCollection;\n/**\n * @fileOverview The **Admin** class is an internal class that allows convenient access to\n * the admin functionality and commands for MongoDB.\n *\n * **ADMIN Cannot directly be instantiated**\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n *\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Use the admin database for the operation\n *   const adminDb = client.db(dbName).admin();\n *\n *   // List all the available databases\n *   adminDb.listDatabases(function(err, dbs) {\n *     test.equal(null, err);\n *     test.ok(dbs.databases.length > 0);\n *     client.close();\n *   });\n * });\n */\n\n/**\n * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n * @return {Admin} a collection instance.\n */\n\n\nfunction Admin(db, topology, promiseLibrary) {\n  if (!(this instanceof Admin)) return new Admin(db, topology); // Internal state\n\n  this.s = {\n    db: db,\n    topology: topology,\n    promiseLibrary: promiseLibrary\n  };\n}\n/**\n * The callback format for results\n * @callback Admin~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object} result The result object if the command was executed successfully.\n */\n\n/**\n * Execute a command\n * @method\n * @param {object} command The command hash\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.command = function (command, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() : {};\n  return executeOperation(this.s.db.s.topology, executeDbAdminCommand.bind(this.s.db), [this.s.db, command, options, callback]);\n};\n/**\n * Retrieve the server information for the current\n * instance of the db client\n *\n * @param {Object} [options] optional parameters for this operation\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.buildInfo = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var cmd = {\n    buildinfo: 1\n  };\n  return executeOperation(this.s.db.s.topology, executeDbAdminCommand.bind(this.s.db), [this.s.db, cmd, options, callback]);\n};\n/**\n * Retrieve the server information for the current\n * instance of the db client\n *\n * @param {Object} [options] optional parameters for this operation\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.serverInfo = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var cmd = {\n    buildinfo: 1\n  };\n  return executeOperation(this.s.db.s.topology, executeDbAdminCommand.bind(this.s.db), [this.s.db, cmd, options, callback]);\n};\n/**\n * Retrieve this db's server status.\n *\n * @param {Object} [options] optional parameters for this operation\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.serverStatus = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeOperation(this.s.db.s.topology, serverStatus, [this, options, callback]);\n};\n/**\n * Ping the MongoDB server and retrieve results\n *\n * @param {Object} [options] optional parameters for this operation\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.ping = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var cmd = {\n    ping: 1\n  };\n  return executeOperation(this.s.db.s.topology, executeDbAdminCommand.bind(this.s.db), [this.s.db, cmd, options, callback]);\n};\n/**\n * Add a user to the database.\n * @method\n * @param {string} username The username.\n * @param {string} password The password.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {object} [options.customData] Custom data associated with the user (only Mongodb 2.6 or higher)\n * @param {object[]} [options.roles] Roles associated with the created user (only Mongodb 2.6 or higher)\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.addUser = function (username, password, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() : {};\n  options = Object.assign({}, options); // Get the options\n\n  options = applyWriteConcern(options, {\n    db: this.s.db\n  }); // Set the db name to admin\n\n  options.dbName = 'admin';\n  return executeOperation(this.s.db.s.topology, addUser, [this.s.db, username, password, options, callback]);\n};\n/**\n * Remove a user from a database\n * @method\n * @param {string} username The username.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] The write concern.\n * @param {number} [options.wtimeout] The write concern timeout.\n * @param {boolean} [options.j=false] Specify a journal write concern.\n * @param {boolean} [options.fsync=false] Specify a file sync write concern.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.removeUser = function (username, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() : {};\n  options = Object.assign({}, options); // Get the options\n\n  options = applyWriteConcern(options, {\n    db: this.s.db\n  }); // Set the db name\n\n  options.dbName = 'admin';\n  return executeOperation(this.s.db.s.topology, removeUser, [this.s.db, username, options, callback]);\n};\n/**\n * Validate an existing collection\n *\n * @param {string} collectionName The name of the collection to validate.\n * @param {object} [options] Optional settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.validateCollection = function (collectionName, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeOperation(this.s.db.s.topology, validateCollection, [this, collectionName, options, callback]);\n};\n/**\n * List the available databases\n *\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.nameOnly=false] Whether the command should return only db names, or names and size info.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.listDatabases = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var cmd = {\n    listDatabases: 1\n  };\n  if (options.nameOnly) cmd.nameOnly = Number(cmd.nameOnly);\n  return executeOperation(this.s.db.s.topology, executeDbAdminCommand.bind(this.s.db), [this.s.db, cmd, options, callback]);\n};\n/**\n * Get ReplicaSet status\n *\n * @param {Object} [options] optional parameters for this operation\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Admin~resultCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nAdmin.prototype.replSetGetStatus = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeOperation(this.s.db.s.topology, replSetGetStatus, [this, options, callback]);\n};\n\nmodule.exports = Admin;","map":null,"metadata":{},"sourceType":"script"}