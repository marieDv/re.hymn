{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    EventEmitter = require('events').EventEmitter,\n    ReadPreference = require('./read_preference'),\n    Logger = require('../connection/logger'),\n    debugOptions = require('../connection/utils').debugOptions,\n    retrieveBSON = require('../connection/utils').retrieveBSON,\n    Pool = require('../connection/pool'),\n    Query = require('../connection/commands').Query,\n    MongoError = require('../error').MongoError,\n    MongoNetworkError = require('../error').MongoNetworkError,\n    TwoSixWireProtocolSupport = require('../wireprotocol/2_6_support'),\n    ThreeTwoWireProtocolSupport = require('../wireprotocol/3_2_support'),\n    BasicCursor = require('../cursor'),\n    sdam = require('./shared'),\n    createClientInfo = require('./shared').createClientInfo,\n    createCompressionInfo = require('./shared').createCompressionInfo,\n    resolveClusterTime = require('./shared').resolveClusterTime,\n    SessionMixins = require('./shared').SessionMixins,\n    relayEvents = require('../utils').relayEvents;\n\nvar collationNotSupported = require('../utils').collationNotSupported;\n\nfunction getSaslSupportedMechs(options) {\n  if (!options) {\n    return {};\n  }\n\n  var authArray = options.auth || [];\n  var authMechanism = authArray[0] || options.authMechanism;\n  var authSource = authArray[1] || options.authSource || options.dbName || 'admin';\n  var user = authArray[2] || options.user;\n\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\n    return {};\n  }\n\n  if (!user) {\n    return {};\n  }\n\n  return {\n    saslSupportedMechs: \"\".concat(authSource, \".\").concat(user)\n  };\n}\n\nfunction getDefaultAuthMechanism(ismaster) {\n  if (ismaster) {\n    // If ismaster contains saslSupportedMechs, use scram-sha-256\n    // if it is available, else scram-sha-1\n    if (Array.isArray(ismaster.saslSupportedMechs)) {\n      return ismaster.saslSupportedMechs.indexOf('SCRAM-SHA-256') >= 0 ? 'scram-sha-256' : 'scram-sha-1';\n    } // Fallback to legacy selection method. If wire version >= 3, use scram-sha-1\n\n\n    if (ismaster.maxWireVersion >= 3) {\n      return 'scram-sha-1';\n    }\n  } // Default for wireprotocol < 3\n\n\n  return 'mongocr';\n}\n\nfunction extractIsMasterError(err, result) {\n  if (err) {\n    return err;\n  }\n\n  if (result && result.result && result.result.ok === 0) {\n    return new MongoError(result.result);\n  }\n} // Used for filtering out fields for loggin\n\n\nvar debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername']; // Server instance id\n\nvar id = 0;\nvar serverAccounting = false;\nvar servers = {};\nvar BSON = retrieveBSON();\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)\n * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#reconnectFailed\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n * @fires Server#topologyOpening\n * @fires Server#topologyClosed\n * @fires Server#topologyDescriptionChanged\n * @property {string} type the topology type.\n * @property {string} parserType the parser type used (c++ or js).\n */\n\nvar Server = function Server(options) {\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Server instance id\n\n  this.id = id++; // Internal state\n\n  this.s = {\n    // Options\n    options: options,\n    // Logger\n    logger: Logger('Server', options),\n    // Factory overrides\n    Cursor: options.cursorFactory || BasicCursor,\n    // BSON instance\n    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n    // Pool\n    pool: null,\n    // Disconnect handler\n    disconnectHandler: options.disconnectHandler,\n    // Monitor thread (keeps the connection alive)\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : true,\n    // Is the server in a topology\n    inTopology: !!options.parent,\n    // Monitoring timeout\n    monitoringInterval: typeof options.monitoringInterval === 'number' ? options.monitoringInterval : 5000,\n    // Topology id\n    topologyId: -1,\n    compression: {\n      compressors: createCompressionInfo(options)\n    },\n    // Optional parent topology\n    parent: options.parent\n  }; // If this is a single deployment we need to track the clusterTime here\n\n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  } // Curent ismaster\n\n\n  this.ismaster = null; // Current ping time\n\n  this.lastIsMasterMS = -1; // The monitoringProcessId\n\n  this.monitoringProcessId = null; // Initial connection\n\n  this.initialConnect = true; // Wire protocol handler, default to oldest known protocol handler\n  // this gets changed when the first ismaster is called.\n\n  this.wireProtocolHandler = new TwoSixWireProtocolSupport(); // Default type\n\n  this._type = 'server'; // Set the client info\n\n  this.clientInfo = createClientInfo(options); // Max Stalleness values\n  // last time we updated the ismaster state\n\n  this.lastUpdateTime = 0; // Last write time\n\n  this.lastWriteDate = 0; // Stalleness\n\n  this.staleness = 0;\n};\n\ninherits(Server, EventEmitter);\nObject.assign(Server.prototype, SessionMixins);\nObject.defineProperty(Server.prototype, 'type', {\n  enumerable: true,\n  get: function get() {\n    return this._type;\n  }\n});\nObject.defineProperty(Server.prototype, 'parserType', {\n  enumerable: true,\n  get: function get() {\n    return BSON.native ? 'c++' : 'js';\n  }\n});\nObject.defineProperty(Server.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function get() {\n    if (!this.ismaster) return null;\n    return this.ismaster.logicalSessionTimeoutMinutes || null;\n  }\n}); // In single server deployments we track the clusterTime directly on the topology, however\n// in Mongos and ReplSet deployments we instead need to delegate the clusterTime up to the\n// tracking objects so we can ensure we are gossiping the maximum time received from the\n// server.\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  enumerable: true,\n  set: function set(clusterTime) {\n    var settings = this.s.parent ? this.s.parent : this.s;\n    resolveClusterTime(settings, clusterTime);\n  },\n  get: function get() {\n    var settings = this.s.parent ? this.s.parent : this.s;\n    return settings.clusterTime || null;\n  }\n});\n\nServer.enableServerAccounting = function () {\n  serverAccounting = true;\n  servers = {};\n};\n\nServer.disableServerAccounting = function () {\n  serverAccounting = false;\n};\n\nServer.servers = function () {\n  return servers;\n};\n\nObject.defineProperty(Server.prototype, 'name', {\n  enumerable: true,\n  get: function get() {\n    return this.s.options.host + ':' + this.s.options.port;\n  }\n});\n\nfunction isSupportedServer(response) {\n  return response && typeof response.maxWireVersion === 'number' && response.maxWireVersion >= 2;\n}\n\nfunction configureWireProtocolHandler(self, ismaster) {\n  // 3.2 wire protocol handler\n  if (ismaster.maxWireVersion >= 4) {\n    return new ThreeTwoWireProtocolSupport();\n  } // default to 2.6 wire protocol handler\n\n\n  return new TwoSixWireProtocolSupport();\n}\n\nfunction disconnectHandler(self, type, ns, cmd, options, callback) {\n  // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n  if (!self.s.pool.isConnected() && self.s.options.reconnect && self.s.disconnectHandler != null && !options.monitoring) {\n    self.s.disconnectHandler.add(type, ns, cmd, options, callback);\n    return true;\n  } // If we have no connection error\n\n\n  if (!self.s.pool.isConnected()) {\n    callback(new MongoError(f('no connection available to server %s', self.name)));\n    return true;\n  }\n}\n\nfunction monitoringProcess(self) {\n  return function () {\n    // Pool was destroyed do not continue process\n    if (self.s.pool.isDestroyed()) return; // Emit monitoring Process event\n\n    self.emit('monitoring', self); // Perform ismaster call\n    // Query options\n\n    var queryOptions = {\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      slaveOk: true\n    }; // Create a query instance\n\n    var query = new Query(self.s.bson, 'admin.$cmd', {\n      ismaster: true\n    }, queryOptions); // Get start time\n\n    var start = new Date().getTime(); // Execute the ismaster query\n\n    self.s.pool.write(query, {\n      socketTimeout: typeof self.s.options.connectionTimeout !== 'number' ? 2000 : self.s.options.connectionTimeout,\n      monitoring: true\n    }, function (err, result) {\n      // Set initial lastIsMasterMS\n      self.lastIsMasterMS = new Date().getTime() - start;\n      if (self.s.pool.isDestroyed()) return; // Update the ismaster view if we have a result\n\n      if (result) {\n        self.ismaster = result.result;\n      } // Re-schedule the monitoring process\n\n\n      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n    });\n  };\n}\n\nvar eventHandler = function eventHandler(self, event) {\n  return function (err) {\n    // Log information of received information if in info mode\n    if (self.s.logger.isInfo()) {\n      var object = err instanceof MongoError ? JSON.stringify(err) : {};\n      self.s.logger.info(f('server %s fired event %s out with message %s', self.name, event, object));\n    } // Handle connect event\n\n\n    if (event === 'connect') {\n      // Issue an ismaster command at connect\n      // Query options\n      var queryOptions = {\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        slaveOk: true\n      }; // Create a query instance\n\n      var compressors = self.s.compression && self.s.compression.compressors ? self.s.compression.compressors : [];\n      var query = new Query(self.s.bson, 'admin.$cmd', Object.assign({\n        ismaster: true,\n        client: self.clientInfo,\n        compression: compressors\n      }, getSaslSupportedMechs(self.s.options)), queryOptions); // Get start time\n\n      var start = new Date().getTime(); // Execute the ismaster query\n\n      self.s.pool.write(query, {\n        socketTimeout: self.s.options.connectionTimeout || 2000\n      }, function (err, result) {\n        // Set initial lastIsMasterMS\n        self.lastIsMasterMS = new Date().getTime() - start;\n        var serverError = extractIsMasterError(err, result);\n\n        if (serverError) {\n          self.destroy();\n          return self.emit('error', serverError);\n        }\n\n        if (!isSupportedServer(result.result)) {\n          self.destroy();\n          var latestSupportedVersion = '2.6';\n          var message = 'Server at ' + self.s.options.host + ':' + self.s.options.port + ' reports wire version ' + (result.result.maxWireVersion || 0) + ', but this version of Node.js Driver requires at least 2 (MongoDB' + latestSupportedVersion + ').';\n          return self.emit('error', new MongoError(message), self);\n        } // Determine whether the server is instructing us to use a compressor\n\n\n        if (result.result && result.result.compression) {\n          for (var i = 0; i < self.s.compression.compressors.length; i++) {\n            if (result.result.compression.indexOf(self.s.compression.compressors[i]) > -1) {\n              self.s.pool.options.agreedCompressor = self.s.compression.compressors[i];\n              break;\n            }\n          }\n\n          if (self.s.compression.zlibCompressionLevel) {\n            self.s.pool.options.zlibCompressionLevel = self.s.compression.zlibCompressionLevel;\n          }\n        } // Ensure no error emitted after initial connect when reconnecting\n\n\n        self.initialConnect = false; // Save the ismaster\n\n        self.ismaster = result.result; // It's a proxy change the type so\n        // the wireprotocol will send $readPreference\n\n        if (self.ismaster.msg === 'isdbgrid') {\n          self._type = 'mongos';\n        } // Add the correct wire protocol handler\n\n\n        self.wireProtocolHandler = configureWireProtocolHandler(self, self.ismaster); // Have we defined self monitoring\n\n        if (self.s.monitoring) {\n          self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);\n        } // Emit server description changed if something listening\n\n\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n\n        if (!self.s.inTopology) {\n          // Emit topology description changed if something listening\n          sdam.emitTopologyDescriptionChanged(self, {\n            topologyType: 'Single',\n            servers: [{\n              address: self.name,\n              arbiters: [],\n              hosts: [],\n              passives: [],\n              type: sdam.getTopologyType(self)\n            }]\n          });\n        } // Log the ismaster if available\n\n\n        if (self.s.logger.isInfo()) {\n          self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));\n        } // Emit connect\n\n\n        self.emit('connect', self);\n      });\n    } else if (event === 'error' || event === 'parseError' || event === 'close' || event === 'timeout' || event === 'reconnect' || event === 'attemptReconnect' || 'reconnectFailed') {\n      // Remove server instance from accounting\n      if (serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) !== -1) {\n        // Emit toplogy opening event if not in topology\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', {\n            topologyId: self.id\n          });\n        }\n\n        delete servers[self.id];\n      }\n\n      if (event === 'close') {\n        // Closing emits a server description changed event going to unknown.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        });\n      } // Reconnect failed return error\n\n\n      if (event === 'reconnectFailed') {\n        self.emit('reconnectFailed', err); // Emit error if any listeners\n\n        if (self.listeners('error').length > 0) {\n          self.emit('error', err);\n        } // Terminate\n\n\n        return;\n      } // On first connect fail\n\n\n      if (self.s.pool.state === 'disconnected' && self.initialConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) !== -1) {\n        self.initialConnect = false;\n        return self.emit('error', new MongoNetworkError(f('failed to connect to server [%s] on first connect [%s]', self.name, err)));\n      } // Reconnect event, emit the server\n\n\n      if (event === 'reconnect') {\n        // Reconnecting emits a server description changed event going from unknown to the\n        // current server type.\n        sdam.emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: sdam.getTopologyType(self)\n        });\n        return self.emit(event, self);\n      } // Emit the event\n\n\n      self.emit(event, err);\n    }\n  };\n};\n/**\n * Initiate server connect\n * @method\n * @param {array} [options.auth=null] Array of auth options to apply on connect\n */\n\n\nServer.prototype.connect = function (options) {\n  var self = this;\n  options = options || {}; // Set the connections\n\n  if (serverAccounting) servers[this.id] = this; // Do not allow connect to be called on anything that's not disconnected\n\n  if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {\n    throw new MongoError(f('server instance in invalid state %s', self.s.pool.state));\n  } // Create a pool\n\n\n  self.s.pool = new Pool(this, Object.assign(self.s.options, options, {\n    bson: this.s.bson\n  })); // Set up listeners\n\n  self.s.pool.on('close', eventHandler(self, 'close'));\n  self.s.pool.on('error', eventHandler(self, 'error'));\n  self.s.pool.on('timeout', eventHandler(self, 'timeout'));\n  self.s.pool.on('parseError', eventHandler(self, 'parseError'));\n  self.s.pool.on('connect', eventHandler(self, 'connect'));\n  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));\n  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed')); // Set up listeners for command monitoring\n\n  relayEvents(self.s.pool, self, ['commandStarted', 'commandSucceeded', 'commandFailed']); // Emit toplogy opening event if not in topology\n\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', {\n      topologyId: self.id\n    });\n  } // Emit opening server event\n\n\n  self.emit('serverOpening', {\n    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n    address: self.name\n  }); // Connect with optional auth settings\n\n  if (options.auth) {\n    self.s.pool.connect.apply(self.s.pool, options.auth);\n  } else {\n    self.s.pool.connect();\n  }\n};\n/**\n * Get the server description\n * @method\n * @return {object}\n */\n\n\nServer.prototype.getDescription = function () {\n  var ismaster = this.ismaster || {};\n  var description = {\n    type: sdam.getTopologyType(this),\n    address: this.name\n  }; // Add fields if available\n\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nServer.prototype.lastIsMaster = function () {\n  return this.ismaster;\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nServer.prototype.unref = function () {\n  this.s.pool.unref();\n};\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isConnected = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isConnected();\n};\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isDestroyed = function () {\n  if (!this.s.pool) return false;\n  return this.s.pool.isDestroyed();\n};\n\nfunction basicWriteValidations(self) {\n  if (!self.s.pool) return new MongoError('server instance is not connected');\n  if (self.s.pool.isDestroyed()) return new MongoError('server instance pool was destroyed');\n}\n\nfunction basicReadValidations(self, options) {\n  basicWriteValidations(self, options);\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error('readPreference must be an instance of ReadPreference');\n  }\n}\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.command = function (ns, cmd, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicReadValidations(self, options);\n  if (result) return callback(result); // Clone the options\n\n  options = Object.assign({}, options, {\n    wireProtocolCommand: false\n  }); // Debug log\n\n  if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({\n    ns: ns,\n    cmd: cmd,\n    options: debugOptions(debugFields, options)\n  }), self.name)); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, cmd)) {\n    return callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n  } // Are we executing against a specific topology\n\n\n  var topology = options.topology || {}; // Create the query object\n\n  var query = self.wireProtocolHandler.command(self.s.bson, ns, cmd, {}, topology, options);\n\n  if (query instanceof MongoError) {\n    return callback(query, null);\n  } // Set slave OK of the query\n\n\n  query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false; // Write options\n\n  var writeOptions = {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    command: true,\n    monitoring: typeof options.monitoring === 'boolean' ? options.monitoring : false,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    requestId: query.requestId,\n    socketTimeout: typeof options.socketTimeout === 'number' ? options.socketTimeout : null,\n    session: options.session || null\n  }; // Write the operation to the pool\n\n  self.s.pool.write(query, writeOptions, callback);\n};\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.insert = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return; // Setup the docs as an array\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.wireProtocolHandler.insert(self.s.pool, ns, self.s.bson, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.update = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'update', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.wireProtocolHandler.update(self.s.pool, ns, self.s.bson, ops, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.remove = function (ns, ops, options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options, options = {}, options = options || {};\n  }\n\n  var result = basicWriteValidations(self, options);\n  if (result) return callback(result); // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return; // error if collation not supported\n\n  if (collationNotSupported(this, options)) {\n    return callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.wireProtocolHandler.remove(self.s.pool, ns, self.s.bson, ops, options, callback);\n};\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options] Options for the cursor\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session=null] Session to use for the operation\n * @param {object} [options.topology] The internal topology of the created cursor\n * @returns {Cursor}\n */\n\n\nServer.prototype.cursor = function (ns, cmd, options) {\n  options = options || {};\n  var topology = options.topology || this; // Set up final cursor type\n\n  var FinalCursor = options.cursorFactory || this.s.Cursor; // Return the cursor\n\n  return new FinalCursor(this.s.bson, ns, cmd, options, topology, this.s.options);\n};\n/**\n * Logout from a database\n * @method\n * @param {string} db The db we are logging out from\n * @param {authResultCallback} callback A callback function\n */\n\n\nServer.prototype.logout = function (dbName, callback) {\n  this.s.pool.logout(dbName, callback);\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nServer.prototype.auth = function (mechanism, db) {\n  var self = this;\n\n  if (mechanism === 'default') {\n    mechanism = getDefaultAuthMechanism(self.ismaster);\n  } // Slice all the arguments off\n\n\n  var args = Array.prototype.slice.call(arguments, 0); // Set the mechanism\n\n  args[0] = mechanism; // Get the callback\n\n  var callback = args[args.length - 1]; // If we are not connected or have a disconnectHandler specified\n\n  if (disconnectHandler(self, 'auth', db, args, {}, callback)) {\n    return;\n  } // Do not authenticate if we are an arbiter\n\n\n  if (this.lastIsMaster() && this.lastIsMaster().arbiterOnly) {\n    return callback(null, true);\n  } // Apply the arguments to the pool\n\n\n  self.s.pool.auth.apply(self.s.pool, args);\n};\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\n\n\nServer.prototype.equals = function (server) {\n  if (typeof server === 'string') return this.name.toLowerCase() === server.toLowerCase();\n  if (server.name) return this.name.toLowerCase() === server.name.toLowerCase();\n  return false;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nServer.prototype.connections = function () {\n  return this.s.pool.allConnections();\n};\n/**\n * Selects a server\n * @return {Server}\n */\n\n\nServer.prototype.selectServer = function (selector, options, callback) {\n  if (typeof selector === 'function' && typeof callback === 'undefined') callback = selector, selector = undefined, options = {};\n  if (typeof options === 'function') callback = options, options = selector, selector = undefined;\n  callback(null, this);\n};\n\nvar listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];\n/**\n * Destroy the server connection\n * @method\n * @param {boolean} [options.emitClose=false] Emit close event on destroy\n * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy\n * @param {boolean} [options.force=false] Force destroy the pool\n */\n\nServer.prototype.destroy = function (options) {\n  if (this._destroyed) return;\n  options = options || {};\n  var self = this; // Set the connections\n\n  if (serverAccounting) delete servers[this.id]; // Destroy the monitoring process if any\n\n  if (this.monitoringProcessId) {\n    clearTimeout(this.monitoringProcessId);\n  } // No pool, return\n\n\n  if (!self.s.pool) {\n    this._destroyed = true;\n    return;\n  } // Emit close event\n\n\n  if (options.emitClose) {\n    self.emit('close', self);\n  } // Emit destroy event\n\n\n  if (options.emitDestroy) {\n    self.emit('destroy', self);\n  } // Remove all listeners\n\n\n  listeners.forEach(function (event) {\n    self.s.pool.removeAllListeners(event);\n  }); // Emit opening server event\n\n  if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n    topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n    address: self.name\n  }); // Emit toplogy opening event if not in topology\n\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', {\n      topologyId: self.id\n    });\n  }\n\n  if (self.s.logger.isDebug()) {\n    self.s.logger.debug(f('destroy called on server %s', self.name));\n  } // Destroy the pool\n\n\n  this.s.pool.destroy(options.force);\n  this._destroyed = true;\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * A server reconnect event, used to verify that the server topology has reconnected\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * A server opening SDAM monitoring event\n *\n * @event Server#serverOpening\n * @type {object}\n */\n\n/**\n * A server closed SDAM monitoring event\n *\n * @event Server#serverClosed\n * @type {object}\n */\n\n/**\n * A server description SDAM change monitoring event\n *\n * @event Server#serverDescriptionChanged\n * @type {object}\n */\n\n/**\n * A topology open SDAM event\n *\n * @event Server#topologyOpening\n * @type {object}\n */\n\n/**\n * A topology closed SDAM event\n *\n * @event Server#topologyClosed\n * @type {object}\n */\n\n/**\n * A topology structure SDAM change event\n *\n * @event Server#topologyDescriptionChanged\n * @type {object}\n */\n\n/**\n * Server reconnect failed\n *\n * @event Server#reconnectFailed\n * @type {Error}\n */\n\n/**\n * Server connection pool closed\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server connection pool caused an error\n *\n * @event Server#error\n * @type {Error}\n */\n\n/**\n * Server destroyed was called\n *\n * @event Server#destroy\n * @type {Server}\n */\n\n\nmodule.exports = Server;","map":null,"metadata":{},"sourceType":"script"}