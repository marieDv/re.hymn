{"ast":null,"code":"'use strict';\n\nvar URL = require('url');\n\nvar qs = require('querystring');\n\nvar dns = require('dns');\n\nvar MongoParseError = require('./error').MongoParseError;\n/**\n * The following regular expression validates a connection string and breaks the\n * provide string into the following capture groups: [protocol, username, password, hosts]\n */\n\n\nvar HOSTS_RX = /(mongodb(?:\\+srv|)):\\/\\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\\/|)(.*)/;\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param {String} srvAddress The address to check against a domain\n * @param {String} parentDomain The domain to check the provided address against\n * @return {Boolean} Whether the provided address matches the parent domain\n */\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  var regex = /^.*?\\./;\n  var srv = \".\".concat(srvAddress.replace(regex, ''));\n  var parent = \".\".concat(parentDomain.replace(regex, ''));\n  return srv.endsWith(parent);\n}\n/**\n * Lookup an `mongodb+srv` connection string, combine the parts and reparse it as a normal\n * connection string.\n *\n * @param {string} uri The connection string to parse\n * @param {object} options Optional user provided connection string options\n * @param {function} callback\n */\n\n\nfunction parseSrvConnectionString(uri, options, callback) {\n  var result = URL.parse(uri, true);\n\n  if (result.hostname.split('.').length < 3) {\n    return callback(new MongoParseError('URI does not have hostname, domain name and tld'));\n  }\n\n  result.domainLength = result.hostname.split('.').length;\n\n  if (result.pathname && result.pathname.match(',')) {\n    return callback(new MongoParseError('Invalid URI, cannot contain multiple hostnames'));\n  }\n\n  if (result.port) {\n    return callback(new MongoParseError(\"Ports not accepted with '\".concat(PROTOCOL_MONGODB_SRV, \"' URIs\")));\n  }\n\n  var srvAddress = \"_mongodb._tcp.\".concat(result.host);\n  dns.resolveSrv(srvAddress, function (err, addresses) {\n    if (err) return callback(err);\n\n    if (addresses.length === 0) {\n      return callback(new MongoParseError('No addresses found at host'));\n    }\n\n    for (var i = 0; i < addresses.length; i++) {\n      if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {\n        return callback(new MongoParseError('Server record does not share hostname with parent URI'));\n      }\n    }\n\n    var base = result.auth ? \"mongodb://\".concat(result.auth, \"@\") : \"mongodb://\";\n    var connectionStrings = addresses.map(function (address, i) {\n      return i === 0 ? \"\".concat(base).concat(address.name, \":\").concat(address.port) : \"\".concat(address.name, \":\").concat(address.port);\n    });\n    var connectionString = \"\".concat(connectionStrings.join(','), \"/\");\n    var connectionStringOptions = []; // Add the default database if needed\n\n    if (result.path) {\n      var defaultDb = result.path.slice(1);\n\n      if (defaultDb.indexOf('?') !== -1) {\n        defaultDb = defaultDb.slice(0, defaultDb.indexOf('?'));\n      }\n\n      connectionString += defaultDb;\n    } // Default to SSL true\n\n\n    if (!options.ssl && (!result.search || result.query['ssl'] == null)) {\n      connectionStringOptions.push('ssl=true');\n    } // Keep original uri options\n\n\n    if (result.search) {\n      connectionStringOptions.push(result.search.replace('?', ''));\n    }\n\n    dns.resolveTxt(result.host, function (err, record) {\n      if (err) {\n        if (err.code !== 'ENODATA') {\n          return callback(err);\n        }\n\n        record = null;\n      }\n\n      if (record) {\n        if (record.length > 1) {\n          return callback(new MongoParseError('Multiple text records not allowed'));\n        }\n\n        record = record[0];\n        record = record.length > 1 ? record.join('') : record[0];\n\n        if (record.indexOf('authSource') === -1 && record.indexOf('replicaSet') === -1) {\n          return callback(new MongoParseError('Text record must only set `authSource` or `replicaSet`'));\n        }\n\n        connectionStringOptions.push(record);\n      } // Add any options to the connection string\n\n\n      if (connectionStringOptions.length) {\n        connectionString += \"?\".concat(connectionStringOptions.join('&'));\n      }\n\n      parseConnectionString(connectionString, callback);\n    });\n  });\n}\n/**\n * Parses a query string item according to the connection string spec\n *\n * @param {Array|String} value The value to parse\n * @return {Array|Object|String} The parsed value\n */\n\n\nfunction parseQueryStringItemValue(value) {\n  if (Array.isArray(value)) {\n    // deduplicate and simplify arrays\n    value = value.filter(function (v, idx) {\n      return value.indexOf(v) === idx;\n    });\n    if (value.length === 1) value = value[0];\n  } else if (value.indexOf(':') > 0) {\n    value = value.split(',').reduce(function (result, pair) {\n      var parts = pair.split(':');\n      result[parts[0]] = parseQueryStringItemValue(parts[1]);\n      return result;\n    }, {});\n  } else if (value.indexOf(',') > 0) {\n    value = value.split(',').map(function (v) {\n      return parseQueryStringItemValue(v);\n    });\n  } else if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {\n    value = value.toLowerCase() === 'true';\n  } else if (!Number.isNaN(value)) {\n    var numericValue = parseFloat(value);\n\n    if (!Number.isNaN(numericValue)) {\n      value = parseFloat(value);\n    }\n  }\n\n  return value;\n}\n/**\n * Parses a query string according the connection string spec.\n *\n * @param {String} query The query string to parse\n * @return {Object|Error} The parsed query string as an object, or an error if one was encountered\n */\n\n\nfunction parseQueryString(query) {\n  var result = {};\n  var parsedQueryString = qs.parse(query);\n\n  for (var key in parsedQueryString) {\n    var value = parsedQueryString[key];\n\n    if (value === '' || value == null) {\n      return new MongoParseError('Incomplete key value pair for option');\n    }\n\n    result[key.toLowerCase()] = parseQueryStringItemValue(value);\n  } // special cases for known deprecated options\n\n\n  if (result.wtimeout && result.wtimeoutms) {\n    delete result.wtimeout;\n    console.warn('Unsupported option `wtimeout` specified');\n  }\n\n  return Object.keys(result).length ? result : null;\n}\n\nvar PROTOCOL_MONGODB = 'mongodb';\nvar PROTOCOL_MONGODB_SRV = 'mongodb+srv';\nvar SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];\n/**\n * Parses a MongoDB connection string\n *\n * @param {*} uri the MongoDB connection string to parse\n * @param {object} [options] Optional settings.\n * @param {parseCallback} callback\n */\n\nfunction parseConnectionString(uri, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Check for bad uris before we parse\n\n  try {\n    URL.parse(uri);\n  } catch (e) {\n    return callback(new MongoParseError('URI malformed, cannot be parsed'));\n  }\n\n  var cap = uri.match(HOSTS_RX);\n\n  if (!cap) {\n    return callback(new MongoParseError('Invalid connection string'));\n  }\n\n  var protocol = cap[1];\n\n  if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {\n    return callback(new MongoParseError('Invalid protocol provided'));\n  }\n\n  if (protocol === PROTOCOL_MONGODB_SRV) {\n    return parseSrvConnectionString(uri, options, callback);\n  }\n\n  var dbAndQuery = cap[4].split('?');\n  var db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;\n  var query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;\n  var parsedOptions = parseQueryString(query);\n\n  if (parsedOptions instanceof MongoParseError) {\n    return callback(parsedOptions);\n  }\n\n  parsedOptions = Object.assign({}, parsedOptions, options);\n  var auth = {\n    username: null,\n    password: null,\n    db: db && db !== '' ? qs.unescape(db) : 'admin'\n  };\n\n  if (cap[4].split('?')[0].indexOf('@') !== -1) {\n    return callback(new MongoParseError('Unescaped slash in userinfo section'));\n  }\n\n  var authorityParts = cap[3].split('@');\n\n  if (authorityParts.length > 2) {\n    return callback(new MongoParseError('Unescaped at-sign in authority section'));\n  }\n\n  if (authorityParts.length > 1) {\n    var authParts = authorityParts.shift().split(':');\n\n    if (authParts.length > 2) {\n      return callback(new MongoParseError('Unescaped colon in authority section'));\n    }\n\n    auth.username = qs.unescape(authParts[0]);\n    auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;\n  }\n\n  var hostParsingError = null;\n  var hosts = authorityParts.shift().split(',').map(function (host) {\n    var parsedHost = URL.parse(\"mongodb://\".concat(host));\n\n    if (parsedHost.path === '/:') {\n      hostParsingError = new MongoParseError('Double colon in host identifier');\n      return null;\n    } // heuristically determine if we're working with a domain socket\n\n\n    if (host.match(/\\.sock/)) {\n      parsedHost.hostname = qs.unescape(host);\n      parsedHost.port = null;\n    }\n\n    if (Number.isNaN(parsedHost.port)) {\n      hostParsingError = new MongoParseError('Invalid port (non-numeric string)');\n      return;\n    }\n\n    var result = {\n      host: parsedHost.hostname,\n      port: parsedHost.port ? parseInt(parsedHost.port) : 27017\n    };\n\n    if (result.port === 0) {\n      hostParsingError = new MongoParseError('Invalid port (zero) with hostname');\n      return;\n    }\n\n    if (result.port > 65535) {\n      hostParsingError = new MongoParseError('Invalid port (larger than 65535) with hostname');\n      return;\n    }\n\n    if (result.port < 0) {\n      hostParsingError = new MongoParseError('Invalid port (negative number)');\n      return;\n    }\n\n    return result;\n  }).filter(function (host) {\n    return !!host;\n  });\n\n  if (hostParsingError) {\n    return callback(hostParsingError);\n  }\n\n  if (hosts.length === 0 || hosts[0].host === '' || hosts[0].host === null) {\n    return callback(new MongoParseError('No hostname or hostnames provided in connection string'));\n  }\n\n  callback(null, {\n    hosts: hosts,\n    auth: auth.db || auth.username ? auth : null,\n    options: Object.keys(parsedOptions).length ? parsedOptions : null\n  });\n}\n\nmodule.exports = parseConnectionString;","map":null,"metadata":{},"sourceType":"script"}